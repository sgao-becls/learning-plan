
# 演进中的架构
## 单体架构时代
### 单体系统
- 定义: 主要工作流程都在一个进程中调用执行.
- 单体架构场景: 规模小: 用户少， 业务量少， 维护人员少， 实施成本少
- 表面的不足: 单体架构无法拆分的， 不易扩展
  - 单体架构的可拆分性
    - 纵向角度: 分层的架构. 外部请求在各个层次之间以不同形式的数据结构进行自上而下的传递， 再由末端层次反向顺序进行反馈.
    - 横向角度: 以包（文件夹）单位的模块划分， 可以按照职责， 功能， 影响范围等维度进行划分. 同样这些包单位可以物理切分成多个工程， 并以JAR， DLL等形式在主工程中组合起来.
    - 从这个方面来说， 单体架构在程序设计方面没有任何问题， 同样也是“可拆分的”
  - 扩展性
    - 业务角度: 通过追加模块来扩展业务
    - 资源角度: 通过在负载均衡器之后部署若干相同的单体系统副本， 来达到提供更多资源， 分流压力， 防错的目的
      - 暴露缺点: 
        - 性能: 模块之间的资源竞争
        - 单进程， 共存亡
- 真正的不足: 
  - 模块间的隔离
  - 模块本身的自治

### 演进
- 想法💡: 单体系统中的模块， 可以独立为子系统. 
  - 独立部署
  - 独立运行
  - 独立更新
- 基于单体三种较有代表性的架构模式
  - 烟囱式架构（Information Silo Architecture）: 又名信息孤岛（Information Island）. 
    - 子系统和主系统完全剥离开来， 完全独立， 甚至用户， 组织， 权限等主数据也完全独立
    - 优势:
      - 从开发者角度来看， 没有问题.
    - 失衡点:
      - 从用户角度来看， 好像有什么不对劲， 貌似没有这样完全独立开来的系统， 用户也不会想要这样的系统（为什么我要在公司里注册两次一样的用户）
  - 微内核架构（Microkernel Architecture）: 又名插件式架构（Plug-in Architecture）
    - 把类似主数据之类的需要共享的信息集中到一起， 组成一个核心系统， 其他子系统都以插件的形式存在， 并依附于核心系统. 
    - 优势:
      - 关注点转移到插件开发
      - 可以按照需求， 自由装配新系统
        - 二次开发难度降低
    - 失衡点:
      - 子系统之间依然独立， 通信要通过核心系统的封装， 会使得核心系统越来越大
      - 依然是单体系统， 最终可能进（tui）化成信息孤岛
  - 事件驱动架构 （Event-Driven Architecture）
    - 通过事件总线（队列管道）， 协调多个子系统共同运作.
    - 优势:
      - 高度解耦
      - 异步远程调用
    - 失衡点:
      - 随着子系统增加， 事件可能泛滥
- 这些架构模式目前依然在使用， 拆分的最终形态也依然是单体系统， 并没有逃离开这一点

## SOA时代
- SOAP协议诞生
- SOA是一堆抽象的概念， 但是从SOAP协议诞生开始， SOA也慢慢有了具体的实施方案
- 从单体架构向基础平台发展
  - 明确了采用SOAP作为远程调用的协议，依靠SOAP协议族（WSDL、UDDI等等）来完成服务的发布、发现和治理
  - 企业服务总线（EBS）， 消息管道， 实现各服务之间的通信
  - 业务流程编排（BPM）
  - 服务数据对象（SDO）， 访问数据源
  - 服务组件架构（SCA）， 定义服务封装的形式和服务运行的容器

## 微服务架构时代
- 微服务: 是一种通过多个小型服务组合来构建单个应用的架构风格，这些服务围绕业务能力而非特定的技术标准来构建各个服务可以采用不同的编程语言，不同的数据存储技术，运行在不同的进程之中服务采取轻量级的通信机制和自动化的部署机制实现通信与运维
  - 围绕业务能力构建（Organized around Business Capability）
  - 分散治理（Decentralized Governance）
  - 通过服务实现独立自治的组件（Componentization via Services）
  - 产品化思维（Products not Projects）
  - 数据去中心化（Decentralized Data Management）
  - 强终端弱冠道（Smart Endpoint and Dumb Pipe）
  - 容错性设计（Design for Failure）
  - 演进式设计（Evolutionary Design）
  - 基础设施自动化（Infrastructure Automation）
- 对开发者来说， 微服务架构让其专注于单一服务的职责
- 对架构者来说， 微服务架构对架构能力要求已提升到史无前例的程度，技术架构者的第一职责就是做决策权衡，有利有弊才需要决策，有取有舍才需要权衡，如果架构者本身的知识面不足以覆盖所需要决策的内容，不清楚其中利弊，恐怕也就无可避免地陷入选择困难症的困境之中
- 优势:
  - 平台化
  - 容器化技术与微服务相辅相成
  - 以spring cloud的全家桶式的框架， 可以快速满足一下我们的好奇心
- 劣势:
  - 运维难度大
  - 不易迁移， 复制

### Kubernetes 容器编排的胜利者
- 下表中列出了同一个分布式服务的问题在传统Spring Cloud中提供的应用层面的解决方案与在Kubernetes中提供的基础设施层面的解决方案

| |Kubernetes	| Spring Cloud|
| ---- | ---- | ---- |
弹性伸缩|	Autoscaling| N/A |
服务发现|	KubeDNS / CoreDNS|	Spring Cloud Eureka|
配置中心|	ConfigMap / Secret|	Spring Cloud Config
服务网关|	Ingress Controller|	Spring Cloud Zuul
负载均衡|	Load Balancer|	Spring Cloud Ribbon
服务安全|	RBAC API|	Spring Cloud Security
跟踪监控|	Metrics API / Dashboard|	Spring Cloud Turbine
降级熔断|	N/A|	Spring Cloud Hystrix

- Kubernetes是基础设施层面的管理， 是针对容器粒度管理的， 相对比较粗， 对服务的熔断， 监控， 认证， 授权， 负载等等细化到服务控制的需求比较弱
- 服务网格（Service Mesh）的边车代理模式（Sidecar proxy）应由而生
  - 由系统自动在服务容器（通常是指Kubernetes的Pod）中注入一个通信代理服务器，以类似网络安全里中间人攻击的方式进行流量劫持，在应用毫无感知的情况下，悄然接管应用所有对外通信这个代理除了实现正常的服务间通信外（称为数据平面通信），还接收来自控制器的指令（称为控制平面通信），根据控制平面中的配置，对数据平面通信的内容进行分析处理，以实现熔断、认证、度量、监控、负载均衡等各种附加功能这样便实现了既不需要在应用层面加入额外的处理代码，也提供了几乎不亚于程序代码的精细管理能力

## 无服务器架构时代
- AWS: Lambda
- Azure: Functions
- 缺点:
  - 冷启动
  - 高并发
- 下一代的架构， 还在发展


# 架构师视角

## 访问远程服务
### RPC
- 面向过程（操作）的思想
### RestFUL
- 六大原则
  - 服务端与客户端分离
  - 无状态
  - 可缓存: 允许客户端和中间的通讯传递者（譬如代理）将部分服务端的应答缓存起来
  - 分层系统: 指客户端一般不需 要知道是否直接连接到了最终的服务器，抑或连接到路径上的中间服务器
  - 统一接口: 将对资源的标准操作映射到HTTP的标准方法上
    - GET、HEAD、POST、PUT、DELETE、TRACE、OPTIONS
    - **面向资源定义** vs 面向过程（操作）定义
      - 譬如，几乎每个系统都有的登录和注销功能，如果你理解成登录对应于login（）服务，注销对应于 logout（）服务这样两个独立服务，这是“符合人类思维”的;如果你理解成登录是 PUT Session，注销是DELETE Session，这样你只需要设计一种“Session 资源”即可满足需求，甚至以后对Session的其他需求，如查询登陆用户的信息，就是 GET Session 而已，其他操作如修改用户信息等都可以被这同一套设计囊括在内，这便是“抽象程度更高”带来的好处
  - 按需代码（可选）
- Richardson Maturity Model（RMM） 成熟度模型
  - 0 The Swamp of Plain Old XML :完全不 REST另外，关于 Plain Old XML 这说法，SO AP表示感觉有被冒犯到 
  - 1 Resources:开始引入资源的概念
  - 2 HTTP Verbs:引入统一接口，映射到 HTTP 协议的方法上
  - 3 Hypermedia Controls: 超文本驱动
- 争议
  - REST没有传输可靠性支持
    - 幂等性的必要性
  - REST缺乏对资源进行“部分”和“批量”的处理能力

## 事务处理
### 本地事务
- 单个服务单个数据源，多个事务同时执行
- 原子性和持久性
  - 原子性保证了事务的多个操作要么都生效要么都不生效，不会存在中间状态
  - 持久性保证了一旦事务生效，就不会再因为任何原因而导致其修改的内容被撤销或丢失
  - 由于写入存在中间状态，所以可能发生以下情形
    - 程序还没修改完三个数据，但数据库已经将其中一个或两个数据的变动写入磁盘，此时出现崩溃，一旦重启之后，数据库必须要有办法得知崩溃前发生过一次不完整的购物操作，将已经修改过的数据从磁盘中恢复成没有改过的样子，以保证原子性
    - 程序已经修改完三个数据，但数据库还未将全部三个数据的变动都写入到磁盘，此时出现崩溃，一旦重启之后，数据库必须要有办法得知崩溃前发生过一次完整的购物操作，将还没来得及写入磁盘的那部分数据重新写入，以保证持久性
  - 崩溃恢复
    - Commit Logging（提交日志）: 在磁盘中写入数据就不能像程序修改内存中变量值那样，直接改变某表某行某列的某个值，而是必须将修改数据这个操作所需的全部信息，包括修改什么数据、数据物理上位于哪个内存页和磁盘块中、从什么值改成什么值，等等，以日志的形式——即仅进行顺序追加的文件写入的形式（这是最高效的写入方式）先记录到磁盘中只有在日志记录全部都安全落盘，数据库在日志中看到代表事务成功提交的“提交记录”（Commit Record）后，才会根据日志上的信息对真正的数据进行修改，修改完成后，再在日志中加入一条“结束记录”（End Record）表示事务已完成持久化
      - 缺点: 性能: 所有对数据的真实修改都必须发生在事务提交以后，即日志写入了Commit Record 之后在此之前，即使磁盘 I/O 有足够空闲
    - Write-Ahead Logging: 基于commit logging的思想， 加入了Undo Log概念， 而之前的重演数据变动的日志被称为Redo log
      - Undo Log 的日志类型，当变动数据写入磁盘前，必须先记录 Undo Log，注明修改了哪个位置的数据、从什么值改成什么值，等等。以便在事务回滚或者崩溃恢复时根据 Undo Log 对提前写入的数据变动进行擦除。
      - 三个阶段的操作
        - 分析阶段
        - 重做阶段（Redo）
        - 回滚阶段（Undo）
- 实现隔离性
  - 并发控制理论（Concurrency Control）决定了隔离程度与并发能力是相互抵触的，隔离程度越高，并发访问时的吞吐量越低
  - 锁
    - 写锁（排他锁）：其他事务不可加读写锁
      - 写锁禁止其他事务施加读锁，而不是禁止事务读取数据
      - 写数据时（CUD)，默认加排他锁
      - 在查询时（R)，默认不加读锁；但是可以手动配置执行
  ```
      SELECT * FROM 数据表 lock in share mode；
  ```
      
    - 读锁（共享锁）：其他事务不可加写锁，可以加读锁
    - 范伟锁：对于某个范围直接加排他锁，在这个范围内的数据不能被写入
  ```
      SELECT * FROM books WHERE price < 100 FOR UPDATE;
  ```

  - 隔离级别：让用户可以调节数据库的加锁方式，取得隔离性和吞吐量之间的平衡
    - 可串行化（Serializable），放弃性能， 全面加锁，让事务操作串行执行
    - 可重复读（Repeatable Read），对事务所涉及的数据加读锁和写锁，且一直持有至事务结束，但不再加范围锁。
      - 弱化了**幻读**问题
    - 读已提交（Read Committed），对事务涉及的数据加的写锁会一直持续到事务结束，但加的读锁在查询操作完成后就马上会释放。
      - 弱化了**不可重复读**问题
    - 读未提交 (Read Uncommitted），对事务涉及的数据只加写锁，会一直持续到事务结束，但完全不加读锁。
      - 弱化**脏读**问题

  - 多版本并发控制（Multiversion concurrency control (MCC or MVCC)）
    - 基本思路是对数据库的任何修改都不会直接覆盖之前的数据，而是产生一个新版副本与老版本共存，以此达到读取时可以完全不加锁的目的
  - 乐观锁 vs 悲观锁


### 全局事务
- 单个服务同时访问多个数据源，多个事务同时执行。即， 相对于数据源而言的**分布式**，而不是服务
- X/OpenXA事务处理框架
  - 多个事务组成一个大的事务时， 某一个事务的回滚会影响到其他事务，造成整个事务的不一致。
  - XA处理事务的**两段式提交**
    - 准备阶段
      - 所有事务向协调者提交状态Prepared/Non-prepared
      - redo log写入，暂时不写入commit record
      - 保持锁的状态
    - 提交阶段
      - 如果都是Prepared状态，那么多个本地事务同时提交Commit
      - 否则都执行回滚
    - 缺点：
      - 单点问题
      - 性能问题
      - 一致性风险
  - **三段式提交**
    - 二段式提交基础上追加了第一步CanCommit，作用是前期判断一下可以顺利提交的可能性
    - 改善了单点问题 - 参与者没有能等到 DoCommit 的消息的话，默认的操作策略将是**提交事务**而不是回滚事务或者持续等待
    - 改善了回滚性能， 因为在写入redo log前判断了可行性


### 共享事务
- 多个服务同时访问同一个数据源
- 共享数据库连接：
  - 构造一个中间服务，用于集中访问数据源，其他多个服务通过接口调用中间服务提供的数据服务接口
    - 由此转化为本地事务
    - 缺点：数据库访问基本上是性能瓶颈，实际中实施的方式都是多个数据库实例相互负载来做数据库代理提供多个服务访问， 而不是反过来用一个代理服务收集大量的数据库访问并通过一个数据库实例执行
 - 中间服务使用消息队列代替，称为**单个数据库的消息驱动更新**
   - 缺点同上，性能问题
- 共享事务目前已经鲜有人用


### 分布式事务
- 多个服务同时访问多个数据源
- The CAP Theorem
  - Consistency，一致性，任何时刻，任何分布式节点中所看到的数据都是符合预期的
  - Availability，可用性，A，代表不间断提供服务的的能力
    - 可靠性：使用平均故障时间（Mean Time Between Failure， MTBF）来度量
    - 可维护性：使用平均修复时间（Mean Time To Repair，MTTR）来度量
    - A=MTBF/(MTBF+MTTR)
  - Tolerance to network Partitions，分区容忍性，代表分布式环境中部分节点因网络原因而彼此失联后，系统仍可以正确提供服务的能力。
  - 在强一致性的前提下，P为不可抗拒的外力，分布式系统无论如何都是无法避免的；A为我们构建分布式系统的主要目的，除非是和类似资金业务相关的系统。那么我们不得不舍弃部分C的属性。最终，只能降低为追求获得**最终一致性**

- 最终一致性
  - **最大努力交付**
    - 事务操作会根据出错的概率进行排序，最不易出错的操作放在后面
    - 工作流编排事务操作，将事务问题转换为工作流状态问题，通过持续重试来保证事务问题最终解决，并达到最终的一致
  - TCC （Try-Confirm-Cancel）
    - 三个阶段
      - Try：尝试执行阶段，完成所有业务可执行性的检查(保障一致性)，并且预留好全部需 用到的业务资源(保障隔离性)。 
      - Confirm：确认执行阶段，不进行任何业务检查，直接使用 Try 阶段准备的资源来完成 业务处理。Confirm 阶段可能会重复执行，因此本阶段所执行的操作需要具备幂等性。 
      - Cancel：取消执行阶段，释放 Try 阶段预留的业务资源。Cancel 阶段可能会重复执行， 也需要满足幂等性
    - 有点类似XA的**两段式提交**
    - 业务入侵
    - 可能存在一些情况导致无法实施Try部分
  - SAGA
    - **长时间事务**
    - SAGA 由两部分操作组成。
      - 大事务拆分若干个小事务，将整个分布式事务 T 分解为 n 个子事务，命名为 T1，T2， ...，Ti，...，Tn。每个子事务都应该是或者能被视为是原子行为。如果分布式事务能够正 常提交，其对数据的影响(最终一致性)应与连续按顺序成功提交 Ti等价。 
      - 为每一个子事务设计对应的补偿动作，命名为 C1，C2，...，Ci，...，Cn。Ti与 Ci必须满 足以下条件:
        - Ti与 Ci都具备幂等性。
        - Ti与 Ci满足交换律(Commutative)，即先执行 Ti还是先执行 Ci，其效果都是一样的。
        - Ci必须能成功提交，即不考虑 Ci本身提交失败被回滚的情形，如出现就必须持续重试 直至成功，或者要人工介入。
      - 如果 T1到 Tn均成功提交，那事务顺利完成，否则，要采取以下两种恢复策略之一:
        - 正向恢复(Forward Recovery):如果 Ti事务提交失败，则一直对 Ti进行重试，直至成 功为止(最大努力交付)。这种恢复方式不需要补偿，适用于事务最终都要成功的场景，譬如在别人的银行账号中扣了款，就一定要给别人发货。正向恢复的执行模式为: T1，T2，...，Ti(失败)，Ti(重试)...，Ti+1，...，Tn。
        - 反向恢复(Backward Recovery):如果 Ti事务提交失败，则一直执行 Ci对 Ti进行补 偿，直至成功为止(最大努力交付)。这里要求 Ci必须(在持续重试后)执行成功。反 向恢复的执行模式为:T1，T2，...，Ti(失败)，Ci(补偿)，...，C2，C1。
  - SEATA（GTA)

## 透明多级分流系统
