
# 演进中的架构
## 单体架构时代
### 单体系统
- 定义: 主要工作流程都在一个进程中调用执行.
- 单体架构场景: 规模小: 用户少, 业务量少, 维护人员少, 实施成本少
- 表面的不足: 单体架构无法拆分的, 不易扩展
  - 单体架构的可拆分性
    - 纵向角度: 分层的架构. 外部请求在各个层次之间以不同形式的数据结构进行自上而下的传递, 再由末端层次反向顺序进行反馈.
    - 横向角度: 以包(文件夹)单位的模块划分, 可以按照职责, 功能, 影响范围等维度进行划分. 同样这些包单位可以物理切分成多个工程, 并以JAR, DLL等形式在主工程中组合起来.
    - 从这个方面来说, 单体架构在程序设计方面没有任何问题, 同样也是“可拆分的”
  - 扩展性
    - 业务角度: 通过追加模块来扩展业务
    - 资源角度: 通过在负载均衡器之后部署若干相同的单体系统副本, 来达到提供更多资源, 分流压力, 防错的目的
      - 暴露缺点: 
        - 性能: 模块之间的资源竞争
        - 单进程, 共存亡
- 真正的不足: 
  - 模块间的隔离
  - 模块本身的自治

### 演进
- 想法💡: 单体系统中的模块, 可以独立为子系统. 
  - 独立部署
  - 独立运行
  - 独立更新
- 基于单体三种较有代表性的架构模式
  - 烟囱式架构(Information Silo Architecture): 又名信息孤岛(Information Island). 
    - 子系统和主系统完全剥离开来, 完全独立, 甚至用户, 组织, 权限等主数据也完全独立
    - 优势:
      - 从开发者角度来看, 没有问题.
    - 失衡点:
      - 从用户角度来看, 好像有什么不对劲, 貌似没有这样完全独立开来的系统, 用户也不会想要这样的系统(为什么我要在公司里注册两次一样的用户)
  - 微内核架构(Microkernel Architecture): 又名插件式架构(Plug-in Architecture)
    - 把类似主数据之类的需要共享的信息集中到一起, 组成一个核心系统, 其他子系统都以插件的形式存在, 并依附于核心系统. 
    - 优势:
      - 关注点转移到插件开发
      - 可以按照需求, 自由装配新系统
        - 二次开发难度降低
    - 失衡点:
      - 子系统之间依然独立, 通信要通过核心系统的封装, 会使得核心系统越来越大
      - 依然是单体系统, 最终可能进(tui)化成信息孤岛
  - 事件驱动架构 (Event-Driven Architecture)
    - 通过事件总线(队列管道), 协调多个子系统共同运作.
    - 优势:
      - 高度解耦
      - 异步远程调用
    - 失衡点:
      - 随着子系统增加, 事件可能泛滥
- 这些架构模式目前依然在使用, 拆分的最终形态也依然是单体系统, 并没有逃离开这一点

## SOA时代
- SOAP协议诞生
- SOA是一堆抽象的概念, 但是从SOAP协议诞生开始, SOA也慢慢有了具体的实施方案
- 从单体架构向基础平台发展
  - 明确了采用SOAP作为远程调用的协议,依靠SOAP协议族(WSDL、UDDI等等)来完成服务的发布、发现和治理
  - 企业服务总线(EBS), 消息管道, 实现各服务之间的通信
  - 业务流程编排(BPM)
  - 服务数据对象(SDO), 访问数据源
  - 服务组件架构(SCA), 定义服务封装的形式和服务运行的容器

## 微服务架构时代
- 微服务: 是一种通过多个小型服务组合来构建单个应用的架构风格,这些服务围绕业务能力而非特定的技术标准来构建。各个服务可以采用不同的编程语言,不同的数据存储技术,运行在不同的进程之中。服务采取轻量级的通信机制和自动化的部署机制实现通信与运维。
  - 围绕业务能力构建(Organized around Business Capability)
  - 分散治理(Decentralized Governance)
  - 通过服务实现独立自治的组件(Componentization via Services)
  - 产品化思维(Products not Projects)
  - 数据去中心化(Decentralized Data Management)
  - 强终端弱冠道(Smart Endpoint and Dumb Pipe)
  - 容错性设计(Design for Failure)
  - 演进式设计(Evolutionary Design)
  - 基础设施自动化(Infrastructure Automation)
- 对开发者来说, 微服务架构让其专注于单一服务的职责
- 对架构者来说, 微服务架构对架构能力要求已提升到史无前例的程度,技术架构者的第一职责就是做决策权衡,有利有弊才需要决策,有取有舍才需要权衡,如果架构者本身的知识面不足以覆盖所需要决策的内容,不清楚其中利弊,恐怕也就无可避免地陷入选择困难症的困境之中
- 优势:
  - 平台化
  - 容器化技术与微服务相辅相成
  - 以spring cloud的全家桶式的框架, 可以快速满足一下我们的好奇心
- 劣势:
  - 运维难度大
  - 不易迁移, 复制

### Kubernetes 容器编排的胜利者
- 下表中列出了同一个分布式服务的问题在传统Spring Cloud中提供的应用层面的解决方案与在Kubernetes中提供的基础设施层面的解决方案

| |Kubernetes	| Spring Cloud|
| ---- | ---- | ---- |
弹性伸缩|	Autoscaling| N/A |
服务发现|	KubeDNS / CoreDNS|	Spring Cloud Eureka|
配置中心|	ConfigMap / Secret|	Spring Cloud Config
服务网关|	Ingress Controller|	Spring Cloud Zuul
负载均衡|	Load Balancer|	Spring Cloud Ribbon
服务安全|	RBAC API|	Spring Cloud Security
跟踪监控|	Metrics API / Dashboard|	Spring Cloud Turbine
降级熔断|	N/A|	Spring Cloud Hystrix

- Kubernetes是基础设施层面的管理, 是针对容器粒度管理的, 相对比较粗, 对服务的熔断, 监控, 认证, 授权, 负载等等细化到服务控制的需求比较弱
- 服务网格(Service Mesh)的边车代理模式(Sidecar proxy)应由而生
  - 由系统自动在服务容器(通常是指Kubernetes的Pod)中注入一个通信代理服务器,以类似网络安全里中间人攻击的方式进行流量劫持,在应用毫无感知的情况下,悄然接管应用所有对外通信。这个代理除了实现正常的服务间通信外(称为数据平面通信),还接收来自控制器的指令(称为控制平面通信),根据控制平面中的配置,对数据平面通信的内容进行分析处理,以实现熔断、认证、度量、监控、负载均衡等各种附加功能。这样便实现了既不需要在应用层面加入额外的处理代码,也提供了几乎不亚于程序代码的精细管理能力。

## 无服务器架构时代
- AWS: Lambda
- Azure: Functions
- 缺点:
  - 冷启动
  - 高并发
- 下一代的架构, 还在发展


# 架构师视角

## 访问远程服务
### RPC
- 面向过程(操作)的思想
### RestFUL
- 六大原则
  - 服务端与客户端分离
  - 无状态
  - 可缓存: 允许客户端和中间的通讯传递者(譬如代理)将部分服务端的应答缓存起来
  - 分层系统: 指客户端一般不需 要知道是否直接连接到了最终的服务器，抑或连接到路径上的中间服务器
  - 统一接口: 将对资源的标准操作映射到HTTP的标准方法上
    - GET、HEAD、POST、PUT、DELETE、TRACE、OPTIONS
    - **面向资源定义** vs 面向过程(操作)定义
      - 譬如，几乎每个系统都有的登录和注销功能，如果你理解成登录对应于login()服务，注销对应于 logout()服务这样两个独立服务，这是“符合人类思维”的;如果你理解成登录是 PUT Session，注销是DELETE Session，这样你只需要设计一种“Session 资源”即可满足需求，甚至以后对Session的其他需求，如查询登陆用户的信息，就是 GET Session 而已，其他操作如修改用户信息等都可以被这同一套设计囊括在内，这便是“抽象程度更高”带来的好处
  - 按需代码(可选)
- Richardson Maturity Model(RMM) 成熟度模型
  - 0 The Swamp of Plain Old XML :完全不 REST。另外，关于 Plain Old XML 这说法，SO AP表示感觉有被冒犯到 。
  - 1 Resources:开始引入资源的概念。
  - 2 HTTP Verbs:引入统一接口，映射到 HTTP 协议的方法上。
  - 3 Hypermedia Controls: 超文本驱动
- 争议
  - REST没有传输可靠性支持
    - 幂等性的必要性
  - REST缺乏对资源进行“部分”和“批量”的处理能力

## 事务处理